<style>
    p{margin: 2px 0;}
    h3{margin: 2px 0;}
    .actionManagement{
      padding: 0;
      margin: 0;
      position: absolute;
    }
    .fotoBlock{
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      justify-content: center;
    }
    #canvasEdihion{
      margin: auto;
    }
    .histogram{
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
    }
    .editFoto{
      margin-top: 20px;
      display: flex;
      justify-content: space-between;
    }
    input[type = "number"]{
      width: 72px;
    }
/*Effect*/
.effect{
  overflow: auto;
  margin: 0;
  width: 40%;
}
.accordion{
  background-color: rgb(242, 242, 242);
    color: #444;
    cursor: pointer;
    padding: 5px;
    width: 100%;
    height: 30px;
    border: none;
    text-align: left;
    outline: none;
    font-size: 13px;
    transition: 0.4s;
    font-weight: 600;
    border-top: 2px solid white;
}
.accordion::after{
    content: '\02795';
    font-size: 9px;
    color: #777;
    float: right;
    margin-right: 5px;
}
.activeAccord:after {
    content: "\2796";
}
.effects{
    display: none;
    background-color: white;
    overflow: hidden;
    width: 100%;
}
</style>
<div class="actionManagement">
  <button id="resetEdit">Reset</button>
</div>
<div class="fotoBlock">
  <canvas id="canvasEdihion"></canvas>

      <div class="histogram">
        <p>Histogram</p>
        <label>
          <input name="rType" type="radio" id="typeValue"  checked/> Black-white
        </label>
        <label>
          <input name="rType" type="radio" /> Color
        </label>        
      
      <canvas id="canvasHistogram" width="256" height="150"></canvas>
    </div>
</div>



<div class="editFoto">

<div class="editFotoPixels" id="editFotoPixels">
  <h3>Edit Foto Pixels</h3>
    <p>Brightness</p>
    <div>
      <label>
        <input id="rangeBrightness" type="range" name = "range" min="-255" max="255" value="0" />
        <span id="valueBrightness" name="number">0</span>
      </label>
    </div>
    <p>Contrast</p>
    <div>
      <label>
        <input id="rangeContrast" type="range" name = "range" min="-255" max="255" value="0" />
        <span id="valueContrast" name="number">0</span>
      </label>
    </div>
    <p>Saturation</p>
    <div>
      <label>
        <input id="rangeSaturation" type="range"  name="range" min="-255" max="255" value="0" />
        <span id="valueSaturation" name="number">0</span>                
      </label>  
    </div>
    <p>Sharp</p>
    <div>
      <label>
        <input id="rangeSharp" type="range"  name="range" min="0.1" max="100" step="0.01" value="0" />
        <span id="valueSharp" name="number">0</span>                
      </label>  
    </div>
    <p>Resize:</p>
                <div id="inputScale">
                <input id="numWidth" type="number" name="rangeScale" value="0"/>x<input class="closet" id="numHeight" type="number" name="rangeScale" value="0" disabled/>
                </div>
                <div>
                  <label>
                    <input id="cbProportions" type="checkbox" checked/>Proportions
                  </label>
                </div>
                <div>
                  <p>Scale methods:</p>
                  <select name="scaleVersion" id="scaleVersion" size="1">
                    <option value="neighbor" selected>Nearest neighbor scaling</option>
                    <option value="bilinear">Bilinear scaling</option>
                    <option value="lanczos">Lanczos scaling</option>
                  </select>    
                </div>
  </div>

<div class="editFotoMethods">
    <h3>Edit foto using methods</h3>
    <p>Rotate</p>
    <div class="radioBlock" id="radioBlock">
      <p><input type="radio" name="rotate" id="0" min="0" value="0" title="rotate 0deg" checked> - 0&#176;</p>
      <p><input type="radio" name="rotate" id="90l" value="90" title="rotate 90deg left"> - 90&#176;</p>
      <p><input type="radio" name="rotate" id="90r" value="-90" title="rotate 90deg right"> - 270&#176;</p>
      <p><input type="radio" name="rotate" id="180" value="180" title="rotate 180deg left"> - 180&#176;</p>
      <p><input type="radio" name="rotate" id="flip" value="270" title="mirror reflection"> - mirror</p>
      <p><input type="radio" name="rotate" id="arbitrary" value="arbitrary" title="arbitrary"> - <input type="number" name="degrees" id="degrees" placeholder="&#177;0-90&#176;" value="0" minlength="1" maxlength="3" min="-90"  max="90" disabled></p>
    </div>
</div>

<div class="effect" id="effect">
  <button type="button" class="accordion" id="negative">Negative effect</button>
  <div class="effects">
    <label><input type="checkbox" checked id="cbRed" name="cd">Red</label>
    <label><input type="checkbox" id="cbGreen" name="cd">Green</label>
    <label><input type="checkbox" id="cbBlue" name="cd">Blue</label>
    <label><input type="checkbox" id="cbAlpha" name="cd">Alpha</label>
  </div>
                                  
  <button type="button" class="accordion" id="discoloration">Discoloration (black and white)</button>
  <div class="effects"><p>Discoloration (black and white)</p></div>

  <button type="button" class="accordion" id="rgbCor">RGB correction</button>
  <div class="effects">
    <label>
      <span style="color: red">R</span>:
      <input id="rangeR" type="range" min="-255" max="255" value="0" name="range"/>
      <span id="valueR" name="number">0</span>
    </label>
    <br/>
    <label>
      <span style="color: green">G</span>:
      <input id="rangeG" type="range" min="-255" max="255" value="0" name="range"/>
      <span id="valueG" name ="number">0</span>
    </label>
    <br/>
    <label>
      <span style="color: blue">B</span>:
      <input id="rangeB" type="range" min="-255" max="255" value="0" name="range"/>
      <span id="valueB" name="number">0</span>
    </label>
  </div>

  <button type="button" class="accordion" id="hslCor">HSL correction</button>
  <div class="effects">
    <label>
      H:
      <input id="rangeH" type="range" min="-180" max="180" value="0" name="range"/>
      <span id="valueH" name="number">0</span>°
    </label>
    <br/>
    <label>
      S:
      <input id="rangeS" type="range" min="-100" max="100" value="0" name="range"/>
      <span id="valueS" name="number">0</span>
    </label>
    <br/>
    <label>
      L:
      <input id="rangeL" type="range" min="-100" max="100" value="0" name="range"/>
      <span id="valueL" name="number">0</span>
    </label>
  </div>

  <button type="button" class="accordion" id="gammaCor">Gamma correction</button>
  <div class="effects">
    <label>
      <input id="rangeGamma" type="range" min="1" max="600" value="100" name="range"/>
      <span id="valueGamma" name="number">0</span>
    </label>
  </div>

  <button type="button" class="accordion" id="blur1">Blur</button>
  <div class="effects">
    <label>
      <input id="rangeSize" type="range" min="0" max="3" value="1" name="range"/>
      <span id="valueSize" name="number">0</span>
    </label>
  </div>

  <button type="button" class="accordion" id="blur2">Blur(H/V)</button>
  <div class="effects">
    <label> 
      <span>H</span>: 
      <input id="rangeHRadius" type="range" min="0" max="25" value="1" name="range"/>
      <span id="valueHRadius" name="number">0</span>
    </label>
    <br>
    <label>
      <span>V</span>:
      <input id="rangeVRadius" type="range" min="0" max="25" value="1" name="range"/>
      <span id="valueVRadius" name="number">0</span>
    </label>
    <br>
    <label>
      <input id="cbLink" type="checkbox" name="cd"/>
      Link
    </label>
  </div>

</div>  

</div>
<script>
/*Загружаем изображение*/
let img = new Image();
    img.src = "./kiza.jpeg"
    img.onload = update;  

/*Функционал ввода данных*/        
//переключатель для изменения размера пропорций
document.getElementById("cbProportions").addEventListener('click',function(){ 
  if (numHeight.className =="open") {
    numHeight.className = "closet";
    numHeight.disabled = true;            
  } else {
    numHeight.className = "open";  
    numHeight.disabled = false;           
  }
})
//переключатель для гистограммы ч-б/цветное
let switchHistogram = document.getElementsByName("rType");
for (let i = 0; i < switchHistogram.length; i++) { 
  switchHistogram[i].addEventListener('change',()=>{  
    update(switchHistogram[i]);  
  });
}
//Изменение положение картинки(Поворот)
let degrees = document.getElementById("degrees"),
    radioBlock = document.getElementById("radioBlock"),
    inputRotation = radioBlock.getElementsByTagName("input"),
    angle = 0;
   for (let i = 0; i < inputRotation.length; i++) {        
      inputRotation[i].addEventListener('change',function (){  
          if (inputRotation[i].value == "arbitrary" || inputRotation[i].id == "degrees") {              
              inputRotation["degrees"].removeAttribute("disabled");
              inputRotation["degrees"].addEventListener('input',function (){
              angle = inputRotation["degrees"].value;
              //добавляем стили для canvas
              document.getElementById("canvasEdihion").style.margin = "auto";  
              document.getElementById("canvasEdihion").style.backgroundColor = "grey"; 
            });              
          } else {
            angle = parseInt(inputRotation[i].value);
            inputRotation["degrees"].setAttribute("disabled","");
            //удаляем стили для canvas
            document.getElementById("canvasEdihion").style.margin = "";  
            document.getElementById("canvasEdihion").style.backgroundColor = ""; 
          }            
      });  
    }
//Effects анимация accordion
var acc = document.getElementsByClassName("accordion");
var i;
  
  for (i = 0; i < acc.length; i++) {
    acc[i].addEventListener("click", function() {
    //Toggle between adding and removing the "active" class to highlight the option that controls the panel
    this.classList.toggle("activeAccord");
    //Switch between hiding and showing the active panel
      var panel = this.nextElementSibling;
      if (panel.style.display === "block") {
        panel.style.display = "none";
      } else {
        panel.style.display = "block";
      }
    });
  }

/*Редоктируем canvas*/
function editCanvas(inImagen, clickItem, clickValue) {
  const width = inImagen.width,
        height = inImagen.height,
        src = new Uint32Array(inImagen.data.buffer);
  //Изменяем canvas      
  //src - пиксельная информация canvas
  //dst - болванка для проведения изменений
 updateCanvasPixel(width, height , function(dst) {
  //сбор параметров для оброботки
      let brightness = parseInt(document.getElementById("rangeBrightness").value), 
          contrast = parseInt(document.getElementById("rangeContrast").value)/255,
          saturation = parseInt(document.getElementById("rangeSaturation").value),
          maxSaturation = (saturation < 0) ? 255 :128,
          mix = (parseInt(document.getElementById("rangeSharp").value))*0.01;
  //отображение параметров
  //edit foto pixel
      document.getElementById("valueBrightness").innerText = brightness;
      document.getElementById("valueContrast").innerText = document.getElementById("rangeContrast").value;
      document.getElementById("valueSaturation").innerText = saturation;
      document.getElementById("valueSharp").innerText = document.getElementById("rangeSharp").value;
  //Effect
      document.getElementById("valueR").innerText = document.getElementById("rangeR").value;
      document.getElementById("valueG").innerText = document.getElementById("rangeG").value;
      document.getElementById("valueB").innerText = document.getElementById("rangeB").value;
      document.getElementById("valueH").innerText = document.getElementById("rangeH").value;
      document.getElementById("valueS").innerText = document.getElementById("rangeS").value;
      document.getElementById("valueL").innerText = document.getElementById("rangeL").value;
      document.getElementById("valueGamma").innerText = document.getElementById("rangeGamma").value;
      document.getElementById("valueSize").innerText = document.getElementById("rangeSize").value;
      document.getElementById("valueHRadius").innerText = document.getElementById("rangeHRadius").value;
      document.getElementById("valueVRadius").innerText = document.getElementById("rangeVRadius").value;

    //Начальная загрузка
    if (clickItem === undefined) {
      for (let i = 0; i < dst.length; i++) {
        dst[i] = src[i];
      }
    }

    //Contrast, Brightness, Saturation
    if (clickItem == "rangeBrightness" || clickItem == "rangeContrast" || clickItem == "rangeSaturation") {
    let avgGray = 0;
      for (let i = 0; i < dst.length; i++) {
        let r = src[i] & 0xFF;
        let g = (src[i] >> 8) & 0xFF;
        let b = (src[i] >> 16) & 0xFF;
        avgGray += (r * 0.2126 + g * 0.7152 + b * 0.0722);
      }
      avgGray /= dst.length;
      
      for (let i = 0; i < dst.length; i++) {
        let r = src[i] & 0xFF;
        let g = (src[i] >> 8) & 0xFF;
        let b = (src[i] >> 16) & 0xFF;
        
        // Contrast
        r += (r - avgGray) * contrast;
        g += (g - avgGray) * contrast;
        b += (b - avgGray) * contrast;
        // Brightness
        r += brightness;
        g += brightness;
        b += brightness;
        //Saturation
        r += (r - avgGray) * saturation / maxSaturation;
        g += (g - avgGray) * saturation / maxSaturation;
        b += (b - avgGray) * saturation / maxSaturation;

        if (r > 255) r = 255;
        else if (r < 0) r = 0;
        if (g > 255) g = 255;
        else if (g < 0) g = 0;
        if (b > 255) b = 255;
        else if (b < 0) b = 0;
        
        dst[i] = (src[i] & 0xFF000000) | (b << 16) | (g << 8) | r;
      }        
    }      
    
    //Sharp
    if (clickItem =="rangeSharp") {
      //Все для работы с матрицей
    let kernel = [[0, -1, 0],//матрица
                 [-1, 5, -1],
                 [0, -1, 0]],
        katet = Math.round(Math.sqrt(kernel.length))+1,//корень 9=3
        half = (katet * 0.5) | 0,//3*0.5=1.5 отбрасываем значения после запятой
        offset = 0,//offset - коэффициент
        div = 1.0;//div - делитель        
    //обработка пикселей
    let dstIndex = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let r = 0, g = 0, b = 0;
          for (let sy = 0; sy < katet; sy++) {
            const yy = Math.min(height - 1, Math.max(0, y + sy - half));
            for (let sx = 0; sx < katet; sx++) {
              const xx = Math.min(width - 1, Math.max(0, x + sx - half));
              let pix = src[yy * width + xx];//обробатываем информацию                     
              r += ((pix & 0xFF) * kernel[sy][sx]);
              g += ((((pix) >> 8) & 0xFF) * kernel[sy][sx]);
              b += ((((pix) >> 16) & 0xFF) * kernel[sy][sx]);
            }
          }          
          red = Math.min(255,Math.max(0, (r*mix)+((src[y * width + x] )&0xFF)*(1-mix) ))&0xFF;
          green = Math.min(255, Math.max(0, (g*mix)+(((src[y * width + x])>> 8)&0xFF)*(1-mix) ))&0xFF;
          blue = Math.min(255, Math.max(0, (b*mix)+(((src[y * width + x])>> 16)&0xFF)*(1-mix) ))&0xFF;
          const alfa = src[y * width + x] & 0xFF000000;//обробатываем информацию
          dst[dstIndex++] = red | ((green) << 8) | ((blue) << 16) | alfa ;//заполняем изменениями            
        }
      }
    }
    
    //Resize
    if (clickItem =="numWidth" || clickItem =="numHeight") {
      if (numHeight.className =="closet") {numHeight.value = Math.round(img.height * numWidth.value / img.width);} 
      const newWidth = numWidth.value;
      const newHeight = numHeight.value;  
      const nameScaleVersion = scaleVersion.value;
      document.getElementById("canvasEdihion").width= newWidth;
      document.getElementById("canvasEdihion").height= newHeight;
        if (nameScaleVersion == "bilinear") {
          //Bilinear scaling  
          function interpolate(a, b, c, d, width, height) {
          return a * (1 - width) * (1 - height)
              + b * width * (1 - height)
              + c * (1 - width) * height
              + d * width * height;
          }
          const xMax = (width - 1);
          const yMax = (height - 1);
          const dx = (xMax + 0.5) / newWidth;
          const dy = (yMax + 0.5) / newHeight;
          let dstOffset = 0;
          for (let i = 0; i < newHeight; i++) {
            for (let j = 0; j < newWidth; j++) {
              const x = (dx * j) >> 0;
              const y = (dy * i) >> 0;
              const xDiff = (dx * j) - x;
              const yDiff = (dy * i) - y;
              const index = y * width + x;
              // a b
              // c d
              const a = src[index];
              const b = (x >= xMax) ? a : src[index + 1];
              const c = (y >= yMax) ? a : src[index + width];
              const d = (y >= yMax) ? b
                  : ((x >= xMax) ? c : (src[index + width + 1]));

              const red = interpolate(
                  a & 0xff, b & 0xff,
                  c & 0xff, d & 0xff,
                  xDiff, yDiff) >> 0;
              const green = interpolate(
                  (a >> 8) & 0xff, (b >> 8) & 0xff,
                  (c >> 8) & 0xff, (d >> 8) & 0xff,
                  xDiff, yDiff) >> 0;
              const blue = interpolate(
                  (a >> 16) & 0xff, (b >> 16) & 0xff,
                  (c >> 16) & 0xff, (d >> 16) & 0xff,
                  xDiff, yDiff) >> 0;
              const alpha = interpolate(
                  (a >> 24) & 0xff, (b >> 24) & 0xff,
                  (c >> 24) & 0xff, (d >> 24) & 0xff,
                  xDiff, yDiff) >> 0;

              dst[dstOffset++] = (alpha << 24) | (blue << 16) | (green << 8) | red;
            }
          }
        } 
        else if(nameScaleVersion == "lanczos"){
         //Lanczos scaling 
         let filterSize = 1;//меняется 1,2,3
         function lanczos(size, x) {
           if (x >= size || x <= -size) return 0;
           if (x === 0) return 1;
           const xpi = x * Math.PI;
           return size * Math.sin(xpi) * Math.sin(xpi / size) / (xpi * xpi);
         }
         function createCache(cachePrecision, filterSize) {
         const cache = {};
         const max = filterSize * filterSize * cachePrecision;
         const iPrecision = 1.0 / cachePrecision;
         for (let cacheKey = 0; cacheKey < max; cacheKey++) {
           const value = lanczos(filterSize, Math.sqrt(cacheKey * iPrecision));
           cache[cacheKey] = value < 0 ? 0 : value;
         }
          return cache;
         };
         const values = [];
         const sx = newWidth / width;
         const sy = newHeight / height;
         const xMax = width - 1;
         const yMax = height - 1;
         const csx = Math.min(1, sx) * Math.min(1, sx);
         const csy = Math.min(1, sy) * Math.min(1, sy);
         const cachePrecision = 1000;
         const cache = createCache(cachePrecision, filterSize);
         let x1et, y1et;
         let y = newHeight;
         while (y--) {
           const sourcePixelY = (y + 0.5) * (1.0 / sy);
           let y1b = sourcePixelY - filterSize;
           if (y1b < 0) y1b = 0;
           let y1e = y1et = sourcePixelY + filterSize;
           if (y1e != y1et) y1e = y1et + 1;
           if (y1e > yMax) y1e = yMax;
           const cy = y * (1.0 / newHeight) - sourcePixelY;
           const y3 = y * newWidth;
           let x = newWidth;
            while (x--) {
              const sourcePixelX = (x + 0.5) * (1.0 / sx);
              let x1b = sourcePixelX - filterSize;
              if (x1b < 0) x1b = 0;
              let x1e = x1et = sourcePixelX + filterSize;
              if (x1e != x1et) x1e = x1et + 1;
              if (x1e > xMax) x1e = xMax;
              const cx = x * (1.0 / newWidth) - sourcePixelX;
              ///
              let total = 0;
              let i = 0;
              for (let y1 = y1b >> 0; y1 <= y1e; y1++) {
                const distanceY = (y1 + cy) * (y1 + cy) * csy;
                for (let x1 = x1b >> 0; x1 <= x1e; x1++) {
                  total += values[i++] = cache[(((x1 + cx) * (x1 + cx) * csx + distanceY) * cachePrecision) >> 0] || 0;
                }
              }
              total = 1.0 / total;
              ///
              let a = 0;
              let r = 0;
              let g = 0;
              let b = 0;
              i = 0;
              for (let y1 = y1b >> 0; y1 <= y1e; y1++) {
                const y2 = y1 * width;
                for (let x1 = x1b >> 0; x1 <= x1e; x1++) {
                  const value = values[i++] * total;
                  const pix = src[((y2 + x1) >> 0)];
                  r += (pix & 0xFF) * value;
                  g += ((pix >> 8) & 0xFF) * value;
                  b += ((pix >> 16) & 0xFF) * value;
                  a += (((pix >> 24) & 0xFF)) * value;
                }
              }
              dst[((x + y3) >> 0)] = (a << 24) | (b << 16) | (g << 8) | r;
            }
          }   
        }
        else{//Nearest neighbor scaling
        const dx = width / newWidth;
        const dy = height / newHeight;
        for (let y = 0; y < newHeight; y++) {
          let srcY = (y * dy) >> 0;    
          for (let x = 0; x < newWidth; x++) {
            let srcX = (x * dx) >> 0;            
            dst[y * newWidth + x] = src[srcY * width + srcX];                       
          }
        }
        }
      
    } 
    
    //Histogram 
    histogram(dst); 
  });

}

/*Гистограмма*/
function histogram(dst) {
  //переключаем отображения гистограммы
  const isValueHistogram = document.getElementById('typeValue').checked;   
    let histBrightness = (new Array(256)).fill(0);
    let histR = (new Array(256)).fill(0);
    let histG = (new Array(256)).fill(0);
    let histB = (new Array(256)).fill(0);
    for (let i = 0; i < dst.length; i++) {
      let r = dst[i] & 0xFF;
      let g = (dst[i] >> 8) & 0xFF;
      let b = (dst[i] >> 16) & 0xFF;
      histBrightness[r]++;
      histBrightness[g]++;
      histBrightness[b]++;
      histR[r]++;
      histG[g]++;
      histB[b]++;
    }
    
    let maxBrightness = 0;
    if (isValueHistogram) {
      for (let i = 1; i < 256; i++) {
        if (maxBrightness < histBrightness[i]) {
          maxBrightness = histBrightness[i]
        }
      }
    } else {
      for (let i = 0; i < 256; i++) {
        if (maxBrightness < histR[i]) {
          maxBrightness = histR[i]
        } else if (maxBrightness < histG[i]) {
          maxBrightness = histG[i]
        } else if (maxBrightness < histB[i]) {
          maxBrightness = histB[i]
        }
      }
    }
    
    const canvas = document.getElementById('canvasHistogram');
    const ctx = canvas.getContext('2d');
    let guideHeight = 8;
    let startY = (canvas.height - guideHeight);
    let dx = canvas.width / 256;
    let dy = startY / maxBrightness;
    ctx.lineWidth = dx;
    ctx.fillStyle = "#fff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    for (let i = 0; i < 256; i++) {
      let x = i * dx;
      if (isValueHistogram) {
        // Value
        ctx.strokeStyle = "#000000";
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, startY - histBrightness[i] * dy);
        ctx.closePath();
        ctx.stroke(); 
      } else {
        // Red
        ctx.strokeStyle = "rgba(220,0,0,0.5)";
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, startY - histR[i] * dy);
        ctx.closePath();
        ctx.stroke(); 
        // Green
        ctx.strokeStyle = "rgba(0,210,0,0.5)";
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, startY - histG[i] * dy);
        ctx.closePath();
        ctx.stroke(); 
        // Blue
        ctx.strokeStyle = "rgba(0,0,255,0.5)";
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, startY - histB[i] * dy);
        ctx.closePath();
        ctx.stroke(); 
      }
      // Guide
      ctx.strokeStyle = 'rgb(' + i + ', ' + i + ', ' + i + ')';
      ctx.beginPath();
      ctx.moveTo(x, startY);
      ctx.lineTo(x, canvas.height);
      ctx.closePath();
      ctx.stroke(); 
    }
}


/*Выводим картнку + копируем информацию о картинке*/
function getImageData() {
  //Создаем поле для Canvas           
  const canvas = document.getElementById("canvasEdihion");
  const ctx = canvas.getContext("2d");    
  canvas.width = img.width;
  canvas.height = img.height;
  //выводим конвас
  ctx.drawImage(img, 0, 0);
  //Передаем информацию в функцию для редоктирования картинки    
  return ctx.getImageData(0, 0, img.width, img.height);  
}

/*Вносим изменения в canvas*/
function updateCanvasPixel(width, height, func) {
  const canvas = document.getElementById("canvasEdihion");
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d");
  const outImagen = ctx.createImageData(width,height);
  const dst = new Uint32Array(outImagen.data.buffer);
  func(dst);
  ctx.putImageData(outImagen, 0,0);
}

/*Оброботчик canvas*/
function update() {
    //Старт
    editCanvas(getImageData());

    //Параметры для изменения editFotoPixels 
    document.getElementById("editFotoPixels").addEventListener("input", clickActions, false);
    //Параметры для врашения editFotoMethods 
    document.getElementById("radioBlock").addEventListener("click", clickActions, false);
    //Параметры для Effect 
    document.getElementById("effect").addEventListener("click", clickActions, false);
    function clickActions(e) {
      if (e.target != e.currentTarget) {
        let clickItem  = e.target.id,
            clickValue  = e.target.value;
            editCanvas(getImageData(), clickItem, clickValue);
            //Добовляем маркер изменения картинки - имя файла
            document.getElementById("canvasEdihion").className = img.src.match(/([^/]+)\.[^\.]+$/)[0];
      }  
    }

    //отображение размера в поле изменения размера
    let numWidth = document.getElementById("numWidth"),
        numHeight = document.getElementById("numHeight"),
        scaleVersion = document.getElementById("scaleVersion");
        numWidth.value = img.width;
        numHeight.value = img.height;
}

/*Reset*/
let resetPages = document.getElementById("resetEdit");
  resetPages.addEventListener('click',function (){   
    let inputSize = document.getElementsByName("range"),
    inputNumber = document.getElementsByName("number"),
    inputRangeScale = document.getElementsByName("rangeScale"),
    inputRangeCd = document.getElementsByName("cd"),
    divEffects = document.getElementsByClassName("effects");     
    for (let i = 0; i <= inputSize.length; i++) 
    { 
      //main+effect
      update(inputSize[i].value = 0);
      update(inputNumber[i].innerText = 0);
      
     //scale
      if (inputRangeScale.value !== " ") {
        inputRangeScale[0].value = document.getElementById("canvasEdihion").width;
        inputRangeScale[1].value = document.getElementById("canvasEdihion").height;                
      }
      document.getElementById("cbProportions").checked =true;
      document.getElementById("scaleVersion")[0].selected = true;

      //rotations
      document.getElementsByName("rotate")[0].checked = true;
      inputRotation[6].setAttribute("disabled","");
      inputRotation[6].value = 0;

      //effect
      inputRangeCd[0].checked = true;
      inputRangeCd[1].checked = false;
      inputRangeCd[2].checked = false;
      inputRangeCd[3].checked = false;
      inputRangeCd[4].checked = false;
      for (let i = 0; i < divEffects.length; i++) {
        divEffects[i].style = "display:none";
      }
      for (let i = 0; i < acc.length; i++) {
        acc[i].className = "accordion";
        
      }


      //удаляем метку для сохранения картинки
      document.getElementById("canvasEdihion").removeAttribute("class");
    } 
  })

</script>