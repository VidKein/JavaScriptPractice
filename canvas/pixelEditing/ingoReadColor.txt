  https://annimon.com/article/3614
  *******************************
  Теория по работе с изображением.
  В RGB цвет представляется как совмещение яркости трёх компонент: красного цвета (RED),
  зелёного (GREEN) и синего (BLUE). Минимальная яркость всех трёх компонент даёт нам чёрный цвет;
  максимальная яркость только красного, разумеется, даёт только красный цвет; максимальная яркость
  всех трёх компонент даёт белый цвет.
  Самый оптимальный способ отображения информации о цвете - целочисленный, с большим диапозоном -> 0-255
  rgb(255,255,255)-белый
  rgb(0,0,0)-ченрный
  ------------------
  rgb(255,0,0)-красный
  rgb(0,255,0)-зеленый
  rgb(0,0,255)-голубой
  --------------------
  Кроме трёх компонент, отвечающих за цвет, существует ещё один компонент, отвечающий за прозрачность.
  Его ещё называют альфа-каналом (A - Alpha). Минимальное значение (0) означает полностью прозрачный
  цвет, а максимальное (255) — непрозрачный.  
  Способы представления цвета.
  --------------------------------------------------------------------------------
  СМЕШИВАНЕ этих (трех) четырех элементов и дает информацию о цвете+(прозрачности) пикселя.
  --------------------------------------------------------------------------------
  Однако, что такое совмещение? В LED индикаторах, это набор из трёх светодиодов.
  В компьютерной графике совмещать компоненты цвета можно различными способами:
  1 - не совмещать. Пусть себе идут поочерёдно в массиве .  
  2 - совмещать в одно число. 24-битное для RGB и 32-битное, если нужен альфа-канал.

  В обоих случаях важно знать порядок следования компонент, потому что бывают разные:
  - RGB. Здесь всё понятно, за красным следует зелёный, а потом синий.
  - ARGB. Как и в предыдущем варианте, только прозрачность идёт первой.
  - RGBA. Сначала цвет, потом прозрачность.
  - BGR. Сначала синий, потом зелёный, потом красный.
  - BGRA. Как и предыдущий, только прозрачность в конце.

  Как три (или четыре) компоненты цвета совмещаются в одно число? Вспоминаем побитовые операции.
  256 (от 0 до 255 включительно градаций) красного * 256 зелёного * 256 синего = 16777216 цветов.
  16777216 цветов * 256 градаций прозрачности = 4294967296 значений.
  Именно столько включает в себя 32-битный unsigned int.
  Кодируется так:
  -------------------------------------------------------
  ARGB: (alpha << 24) | (red << 16) | (green << 8) | blue
  -------------------------------------------------------
  ABGR: (alpha << 24) | (blue << 16) | (green << 8) | red
  -------------------------------------------------------
  RGBA: (red << 24) | (green << 16) | (blue << 8) | alpha
  -------------------------------------------------------
  Пример 1 - Uint8ClampedArray() - масив RGBA [76, 113, 191, 255,.......] 
  Пример 2 - Uint32Array(типизированный массив - являются массивоподобными
  объектами, предоставляющими механизм доступа к сырым двоичным данным) - ОДНО ЧИСЛО
  Uint32Array(1080000) [4290736460, 4290802253, 4290868046, 4290868046,...]
  https://hacks.mozilla.org/2011/12/faster-canvas-pixel-manipulation-with-typed-arrays/
  ПОЧЕМУ 2 вариант Л У Ч Ш Е :
  Ранее нам приходилось записывать значения цвета в одномерный массив данных изображения по одному каналу
  за раз. Воспользовавшись преимуществами типизированных массивов и объектов ArrayBuffer и ArrayBufferView, 
  мы можем записывать значения цвета в массив данных изображения по всем пикселям за раз!
  ***********************************
  Работа с изображением.
  Координаты
  1. ДВУХМЕРНЫЙ МАССИВ
  Верхний угол ЭКРАНА    
            x
      _0_1_2_3_4_5_ 
    0|
    1|    0    
 y  2|   0 0
    3|   0 0  
    4|    0
  img[y,x] -> img[1,2]
  2. ОДНОМЕРНЫЙ МАССИВ
  _0_1_2_3_4_5_6_7_8_9_10_11_12_13_14_15_16_17_18_19_20_21_22_23_24_25_26_27_28_29_30  
                   0            0     0           0     0              0
  img[y*widh+x] -> img[1*6+2]=img[8]